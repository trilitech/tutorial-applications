import Test = Test.Next;
import Tezos = Tezos.Next;

namespace TacoShop {
  export type taco_supply = { current_stock: nat, max_price: tez };
  export type taco_data = map<nat, taco_supply>;
  export type admin_address = address;
  export type storage = {
    admin_address: admin_address,
    taco_data: taco_data,
  };

  export const default_taco_data: taco_data = Map.literal ([
    [1n, { current_stock: 50n, max_price: 50tez }],
    [2n, { current_stock: 20n, max_price: 75tez }]
  ]);

  // Internal function to get the price of a taco
  const get_taco_price_internal = (taco_kind_index: nat, taco_data: taco_data): tez => {
    const taco_kind: taco_supply =
      match (Map.find_opt(taco_kind_index, taco_data)) {
        when(Some(kind)): kind;
        when(None()): failwith("Unknown kind of taco")
      };
    return taco_kind.max_price / taco_kind.current_stock;
  }

  @view
  const get_taco_price = (taco_kind_index: nat, storage: storage): tez =>
    get_taco_price_internal(taco_kind_index, storage.taco_data);

  // Buy a taco
  @entry
  const buy_taco = (taco_kind_index: nat, storage: storage): [
      list<operation>,
      storage
    ] => {

    const { admin_address, taco_data } = storage;

    // Retrieve the kind of taco from the contracts storage or fail
    const taco_kind: taco_supply =
      match (Map.find_opt(taco_kind_index, taco_data)) {
        when(Some(kind)): kind;
        when(None()): failwith("Unknown kind of taco");
      };

    // Get the current price of this type of taco
    const current_purchase_price = get_taco_price_internal(taco_kind_index, taco_data);

    // Verify that the caller sent the correct amount of tez
    if ((Tezos.get_amount()) != current_purchase_price) {
      return failwith("Sorry, the taco you are trying to purchase has a different price");
    }

    // Verify that there is at least one of this type of taco
    if (taco_kind.current_stock == 0n) {
      return failwith("Sorry, we are out of this type of taco");
    }

    // Update the storage with the new quantity of tacos
    const updated_taco_data: taco_data = Map.update(
      taco_kind_index,
      (Some (({...taco_kind, current_stock: abs (taco_kind.current_stock - 1n) }))),
      taco_data);

    const updated_storage: storage = {
      admin_address: admin_address,
      taco_data: updated_taco_data,
    };

    return [[], updated_storage];
  }

  @entry
  const payout = (_u: unit, storage: storage): [
      list<operation>,
      storage
    ] => {

    // Ensure that only the admin can call this entrypoint
    if (Tezos.get_sender() != storage.admin_address) {
      failwith("Only the admin can call this entrypoint");
    }

    // Create contract object that represents the target account
    const receiver_contract =  match(Tezos.get_contract_opt(storage.admin_address)) {
      when(Some(contract)): contract;
      when(None): failwith("Couldn't find account");
    };

    // Create operation to send tez
    const payout_operation = Tezos.Operation.transaction(unit, Tezos.get_balance(), receiver_contract);

    // Restore stock of tacos
    const new_storage: storage = {
      admin_address: storage.admin_address,
      taco_data: default_taco_data,
    };

    return [[payout_operation], new_storage];
  }
};

// Convenience function to get current taco price
const get_taco_price = (untyped_address: address, taco_kind_index: nat): tez => {
    const view_result_option: option<tez> = Tezos.View.call("get_taco_price", taco_kind_index, untyped_address);
    return match(view_result_option) {
      when(Some(cost_mutez)): cost_mutez;
      when(None()): Test.failwith("Couldn't get the price of the taco.")
    };
}

// Convenience function for testing equality in maps
const eq_in_map = (r: TacoShop.taco_supply, m: TacoShop.taco_data, k: nat) =>
  match(Map.find_opt(k, m)) {
    when(None):
      false
    when(Some(v)):
      v.current_stock == r.current_stock && v.max_price == r.max_price
  };

const test = (() => {

  // Set the initial storage and deploy the contract
  const admin_address: address = Test.Account.address(0n);
  const initial_storage: TacoShop.storage = {
    admin_address: admin_address,
    taco_data: TacoShop.default_taco_data,
  }
  const contract = Test.Originate.contract(contract_of(TacoShop), initial_storage, 0tez);

  // Get the current price of a taco
  const untyped_address = Test.Typed_address.to_address(contract.taddr);
  const current_price = get_taco_price(untyped_address, 1n);

  // Purchase a taco
  const success_result =
    Test.Contract.transfer(
      Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),
      1n,
      current_price
    );

  // Verify that the stock was updated
  match(success_result) {
    when(Success(_s)):
    do {
      const storage = Test.Typed_address.get_storage(contract.taddr);
      // Check that the stock has been updated correctly
      Assert.assert(
        eq_in_map(
          { current_stock: 49n, max_price: 50000000mutez },
          storage.taco_data,
          1n
        ));
      // Check that the amount of the other taco type has not changed
      Assert.assert(eq_in_map(
          { current_stock: 20n, max_price: 75000000mutez },
          storage.taco_data,
          2n
        )
      );
      Test.IO.log("Successfully bought a taco");
    }
    when(Fail(err)): failwith(err);
  };

  // Fail to purchase a taco without sending enough tez
  const fail_result =
    Test.Contract.transfer(
      Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),
      1n,
      1mutez
    );
  match(fail_result) {
    when(Success(_s)): failwith("Test was able to buy a taco for the wrong price");
    when(Fail(_err)): Test.IO.log("Contract successfully blocked purchase with incorrect price");
  };

  // Test the payout entrypoint as the administrator
  const admin_balance_before = Test.Address.get_balance(admin_address);
  Test.State.set_source(admin_address);
  const payout_result =
    Test.Contract.transfer(
      Test.Typed_address.get_entrypoint("payout", contract.taddr),
      unit,
      0tez
    );
  match(payout_result) {
    when(Success(_s)):
      do {
        const storage = Test.Typed_address.get_storage(contract.taddr);
        // Check that the stock has been reset
        Assert.assert(
          eq_in_map(
            Map.find(1n, TacoShop.default_taco_data),
            storage.taco_data,
            1n
          ));
        Assert.assert(
          eq_in_map(
            Map.find(2n, TacoShop.default_taco_data),
            storage.taco_data,
            2n
          ));
        Test.IO.log("Successfully reset taco storage");
      }
    when(Fail(_err)): failwith("Failed to reset taco storage");
  };
  // Check that the admin account got a payout
  const admin_balance_after = Test.Address.get_balance(admin_address);
  Assert.assert(Test.Compare.lt(admin_balance_before, admin_balance_after));

  // Verify that the entrypoint fails if called by someone else
  const other_user_account = Test.Account.address(1n);
  Test.State.set_source(other_user_account);
  const failed_payout_result =
    Test.Contract.transfer(
      Test.Typed_address.get_entrypoint("payout", contract.taddr),
      unit,
      0tez
    );
  match(failed_payout_result) {
    when(Success(_s)): failwith("A non-admin user was able to call the payout entrypoint");
    when(Fail(_err)): Test.IO.log("Successfully prevented a non-admin user from calling the payout entrypoint");
  };

}) ();
